<!DOCTYPE html>
<html>
<head>
    {{template "shared_head"}}
    <title>/jank/{{.Board.Name}}/</title>
    <style>
        {{template "shared_styles"}}
        .container {
            max-width: 800px;
        }
        .board-title {
            font-size: 1.8em;
            margin-bottom: 5px;
            color: var(--color-text-strong);
        }
        .board-meta {
            color: var(--color-text-muted);
            margin-bottom: 20px;
        }
        .threads {
            list-style-type: none;
            padding: 0;
        }
        .thread {
            border-bottom: 1px solid var(--color-border-strong);
            padding: 15px 0;
        }
        .thread:last-child {
            border-bottom: none;
        }
        .thread-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            gap: 8px;
            flex-wrap: wrap;
        }
        .thread-title {
            font-weight: bold;
            color: var(--color-text-strong);
        }
        .thread-date {
            color: var(--color-text-muted);
            font-size: 0.9em;
        }
        .thread-author {
            color: var(--color-text-muted);
            font-size: 0.9em;
        }
        .thread-meta {
            margin-top: 6px;
            color: var(--color-text-muted);
            font-size: 0.85em;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }
        .thread-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        .thread-tag {
            padding: 2px 8px;
            border-radius: 999px;
            background: var(--color-tag-bg);
            color: var(--color-tag-text);
            font-size: 0.75em;
            letter-spacing: 0.02em;
        }
        .format-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 12px 0 18px;
        }
        .format-filter {
            border: 1px solid var(--color-filter-border);
            background: var(--color-filter-bg);
            color: var(--color-filter-text);
            border-radius: 999px;
            padding: 4px 12px;
            font-size: 0.85em;
            cursor: pointer;
        }
        .format-filter.is-active {
            background: var(--color-filter-active-bg);
            border-color: var(--color-filter-active-border);
            color: var(--color-filter-active-text);
        }
        footer {
            margin-top: 40px;
        }
        @media (max-width: 600px) {
            .thread-header {
                flex-direction: column;
                align-items: flex-start;
            }
            .thread-date {
                margin-top: 5px;
            }
            .format-filters {
                gap: 6px;
            }
            .format-filter {
                flex: 1 1 auto;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    {{template "site_header" (printf "/jank%s" .Board.Name)}}

    <div class="container">
        {{template "auth_bar" .}}
        <div class="board-title">{{.Board.Name}} (Board #{{.Board.ID}})</div>
        <div class="board-meta">{{.Board.Description}}</div>

        {{if .IsAuthenticated}}
            <a href="/view/board/newthread/{{.Board.ID}}">Create a new thread</a>
        {{else}}
            <a href="/login?next={{.CurrentPath | urlquery}}">Log in to create a new thread</a>
        {{end}}

        <h2>Threads ðŸ§µ</h2>
        <div class="format-filters" aria-label="Format filters">
            <button class="format-filter" type="button" data-format="standard">Standard</button>
            <button class="format-filter" type="button" data-format="modern">Modern</button>
            <button class="format-filter" type="button" data-format="pioneer">Pioneer</button>
            <button class="format-filter" type="button" data-format="edh">EDH</button>
            <button class="format-filter" type="button" data-format="clear">Clear</button>
        </div>
        {{if .Board.Threads}}
            <ul class="threads">
            {{range .Board.Threads}}
                <li class="thread">
                    <div class="thread-header">
                        <div class="thread-title"><a href="/view/thread/{{.ID}}">Thread #{{.ID}}: {{.Title}}</a></div>
                        <div class="thread-date">Created: {{.Created.Format "Jan 2, 2006 at 3:04pm"}}</div>
                    </div>
                    {{if .Author}}
                        <div class="thread-author">Started by <a href="/user/{{.Author | urlquery}}">{{.Author}}</a></div>
                    {{end}}
                    <div class="thread-meta">
                        <span>Replies: {{.ReplyCount}}</span>
                        <span>Last bump: {{.LastBump.Format "Jan 2, 2006 at 3:04pm"}}</span>
                        {{if .CardTags}}
                            <span class="thread-tags">
                                {{range .CardTags}}
                                    <span class="thread-tag">[[ {{.}} ]]</span>
                                {{end}}
                            </span>
                        {{end}}
                    </div>
                </li>
            {{end}}
            </ul>
        {{else}}
            <p>No threads yet. Be the first to create one!</p>
            {{if .IsAuthenticated}}
                <p><a href="/view/board/newthread/{{.Board.ID}}">Start a new thread</a></p>
            {{else}}
                <p><a href="/login?next={{.CurrentPath | urlquery}}">Log in to start a thread</a></p>
            {{end}}
        {{end}}

        {{template "footer_home" .}}
    </div>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            const threadTitles = document.querySelectorAll('.thread-title a');
            const boardTitle = document.querySelector('.board-title');
            const boardMeta = document.querySelector('.board-meta');
            const cardNamePattern = /\[\[([^\]]+)\]\]/g;

            const createCardMarkup = (name) => {
                const safeName = name.trim();
                return `<span class="mtg-card" data-card-name="${safeName}">[[ ${safeName} ]]</span>`;
            };

            threadTitles.forEach(title => {
                title.innerHTML = title.innerHTML.replace(cardNamePattern, (_, name) => createCardMarkup(name));
            });

            if (boardTitle) {
                boardTitle.innerHTML = boardTitle.innerHTML.replace(cardNamePattern, (_, name) => createCardMarkup(name));
            }

            if (boardMeta) {
                boardMeta.innerHTML = boardMeta.innerHTML.replace(cardNamePattern, (_, name) => createCardMarkup(name));
            }

            const cardImageCache = new Map();

            function initCardTooltips() {
                const cards = document.querySelectorAll(".mtg-card");
                cards.forEach(card => {
                    if (card.querySelector(".mtg-card-tooltip")) {
                        return;
                    }
                    const name = card.dataset.cardName || card.textContent.replace(/\[\[|\]\]/g, "").trim();
                    const tooltip = document.createElement("span");
                    tooltip.className = "mtg-card-tooltip";
                    tooltip.innerHTML = `
                        <span class="mtg-card-tooltip-title">${name}</span>
                        <span class="mtg-card-tooltip-loading">Loading art...</span>
                        <img class="mtg-card-tooltip-image is-loading" alt="Card art for ${name}" loading="lazy" />
                    `;
                    card.appendChild(tooltip);

                    const loadArt = async () => {
                        if (tooltip.dataset.loaded === "true") {
                            return;
                        }
                        tooltip.dataset.loaded = "true";
                        const img = tooltip.querySelector(".mtg-card-tooltip-image");
                        const loading = tooltip.querySelector(".mtg-card-tooltip-loading");
                        if (!img || !loading) {
                            return;
                        }
                        const finalizeLoaded = () => {
                            img.classList.remove("is-loading");
                            loading.remove();
                        };
                        if (cardImageCache.has(name)) {
                            img.src = cardImageCache.get(name);
                            img.addEventListener("load", finalizeLoaded, { once: true });
                            img.addEventListener("error", () => {
                                img.classList.remove("is-loading");
                                loading.textContent = "Art unavailable.";
                            }, { once: true });
                            return;
                        }
                        try {
                            const fetchCard = async (url) => {
                                const response = await fetch(url);
                                if (!response.ok) {
                                    return null;
                                }
                                return response.json();
                            };
                            const exactUrl = `https://api.scryfall.com/cards/named?exact=${encodeURIComponent(name)}`;
                            const fuzzyUrl = `https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(name)}`;
                            let data = await fetchCard(exactUrl);
                            if (!data) {
                                data = await fetchCard(fuzzyUrl);
                            }
                            if (!data) {
                                throw new Error("Scryfall lookup failed");
                            }
                            const imageUrl =
                                data.image_uris?.normal ||
                                data.image_uris?.small ||
                                data.card_faces?.[0]?.image_uris?.normal ||
                                data.card_faces?.[0]?.image_uris?.small;
                            if (!imageUrl) {
                                throw new Error("Missing card art");
                            }
                            cardImageCache.set(name, imageUrl);
                            img.src = imageUrl;
                            img.addEventListener("load", finalizeLoaded, { once: true });
                            img.addEventListener("error", () => {
                                img.classList.remove("is-loading");
                                loading.textContent = "Art unavailable.";
                            }, { once: true });
                        } catch (error) {
                            img.classList.remove("is-loading");
                            loading.textContent = "Art unavailable.";
                        }
                    };

                    card.addEventListener("mouseenter", loadArt, { once: true });
                    let pressTimer = null;
                    const clearPressTimer = () => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    };
                    const deactivateOthers = () => {
                        cards.forEach(other => {
                            if (other !== card) {
                                other.classList.remove("is-active");
                            }
                        });
                    };
                    card.addEventListener("touchstart", (event) => {
                        clearPressTimer();
                        pressTimer = window.setTimeout(() => {
                            deactivateOthers();
                            card.classList.add("is-active");
                            loadArt();
                        }, 300);
                        event.stopPropagation();
                    }, { passive: true });
                    card.addEventListener("touchend", clearPressTimer);
                    card.addEventListener("touchmove", clearPressTimer);
                    card.addEventListener("click", (event) => {
                        if (card.classList.contains("is-active")) {
                            card.classList.remove("is-active");
                            event.preventDefault();
                            event.stopPropagation();
                            return;
                        }
                    });
                });
            }

            document.addEventListener("touchstart", (event) => {
                if (!event.target.closest(".mtg-card")) {
                    document.querySelectorAll(".mtg-card.is-active").forEach(card => {
                        card.classList.remove("is-active");
                    });
                }
            }, { passive: true });

            function initFormatFilters() {
                const filterButtons = document.querySelectorAll(".format-filter");
                const threads = document.querySelectorAll(".thread");
                const formatAliases = {
                    commander: "edh",
                    edh: "edh",
                    standard: "standard",
                    modern: "modern",
                    pioneer: "pioneer"
                };

                threads.forEach(thread => {
                    const tags = Array.from(thread.querySelectorAll(".thread-tag")).map(tag => {
                        return tag.textContent.replace(/\[\[|\]\]/g, "").trim().toLowerCase();
                    });
                    const formats = new Set();
                    tags.forEach(tag => {
                        const mapped = formatAliases[tag];
                        if (mapped) {
                            formats.add(mapped);
                        }
                    });
                    thread.dataset.formats = Array.from(formats).join(",");
                });

                function applyFilters() {
                    const activeFormats = Array.from(filterButtons)
                        .filter(btn => btn.classList.contains("is-active") && btn.dataset.format !== "clear")
                        .map(btn => btn.dataset.format);

                    threads.forEach(thread => {
                        if (activeFormats.length === 0) {
                            thread.style.display = "";
                            return;
                        }
                        const threadFormats = (thread.dataset.formats || "").split(",").filter(Boolean);
                        const matches = activeFormats.some(format => threadFormats.includes(format));
                        thread.style.display = matches ? "" : "none";
                    });
                }

                filterButtons.forEach(button => {
                    button.addEventListener("click", () => {
                        if (button.dataset.format === "clear") {
                            filterButtons.forEach(btn => btn.classList.remove("is-active"));
                            applyFilters();
                            return;
                        }
                        button.classList.toggle("is-active");
                        applyFilters();
                    });
                });
            }

            initCardTooltips();
            initFormatFilters();
        });
    </script>
</body>
</html>
