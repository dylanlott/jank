package app

import (
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"database/sql"
	"encoding/base64"
	"fmt"
	"math/big"
	"sort"
	"strings"
	"time"
)

// ------------------- Database & Utility -------------------

// migrate creates the necessary tables if they don't exist.
func migrate(db *sql.DB) error {
	switch dbDriver {
	case "pgx":
		return migratePostgres(db)
	case "sqlite3":
		return migrateSQLite(db)
	default:
		return fmt.Errorf("unsupported database driver %q", dbDriver)
	}
}

func migrateSQLite(db *sql.DB) error {
	boardsStmt := `
	CREATE TABLE IF NOT EXISTS boards (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		name TEXT NOT NULL,
		description TEXT
	);`
	usersStmt := `
	CREATE TABLE IF NOT EXISTS users (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		username TEXT NOT NULL UNIQUE,
		password_hash TEXT NOT NULL,
		created DATETIME NOT NULL
	);`
	threadsStmt := `
	CREATE TABLE IF NOT EXISTS threads (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		board_id INTEGER NOT NULL,
		title TEXT NOT NULL,
		author TEXT,
		tags TEXT,
		created DATETIME NOT NULL,
		FOREIGN KEY (board_id) REFERENCES boards(id)
	);`
	postsStmt := `
	CREATE TABLE IF NOT EXISTS posts (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		thread_id INTEGER NOT NULL,
		author TEXT,
		content TEXT NOT NULL,
		created DATETIME NOT NULL,
		number TEXT,
		flair TEXT,
		deleted_at DATETIME,
		deleted_by TEXT,
		deleted_reason TEXT,
		FOREIGN KEY (thread_id) REFERENCES threads(id)
	);`
	reportsStmt := `
	CREATE TABLE IF NOT EXISTS reports (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		post_id INTEGER NOT NULL,
		category TEXT NOT NULL,
		reason TEXT,
		reported_by TEXT,
		created DATETIME NOT NULL,
		resolved_at DATETIME,
		resolved_by TEXT,
		resolution_note TEXT,
		FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE
	);`
	reportsIndexStmt := `CREATE INDEX IF NOT EXISTS reports_post_id_idx ON reports(post_id);`
	cardTreesStmt := `
	CREATE TABLE IF NOT EXISTS card_trees (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		scope_type TEXT NOT NULL,
		scope_id INTEGER NOT NULL,
		title TEXT NOT NULL,
		description TEXT,
		created_by TEXT NOT NULL,
		created_at DATETIME NOT NULL,
		updated_at DATETIME NOT NULL,
		is_primary BOOLEAN NOT NULL DEFAULT 0
	);`
	cardTreeNodesStmt := `
	CREATE TABLE IF NOT EXISTS card_tree_nodes (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		tree_id INTEGER NOT NULL,
		parent_id INTEGER,
		card_name TEXT NOT NULL,
		position INTEGER NOT NULL DEFAULT 0,
		created_by TEXT NOT NULL,
		created_at DATETIME NOT NULL,
		updated_at DATETIME NOT NULL,
		FOREIGN KEY (tree_id) REFERENCES card_trees(id) ON DELETE CASCADE,
		FOREIGN KEY (parent_id) REFERENCES card_tree_nodes(id) ON DELETE CASCADE
	);`
	cardTreeAnnotationsStmt := `
	CREATE TABLE IF NOT EXISTS card_tree_annotations (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		node_id INTEGER NOT NULL,
		kind TEXT NOT NULL,
		body TEXT NOT NULL,
		label TEXT,
		tags TEXT,
		source_post_id INTEGER,
		created_by TEXT NOT NULL,
		created_at DATETIME NOT NULL,
		FOREIGN KEY (node_id) REFERENCES card_tree_nodes(id) ON DELETE CASCADE,
		FOREIGN KEY (source_post_id) REFERENCES posts(id)
	);`

	if _, err := db.Exec(boardsStmt); err != nil {
		return err
	}
	if _, err := db.Exec(usersStmt); err != nil {
		return err
	}
	if _, err := db.Exec(threadsStmt); err != nil {
		return err
	}
	if err := ensureThreadsAuthorColumn(db); err != nil {
		return err
	}
	if err := ensureThreadsTagsColumn(db); err != nil {
		return err
	}
	if _, err := db.Exec(postsStmt); err != nil {
		return err
	}
	if err := ensurePostModerationColumns(db); err != nil {
		return err
	}
	if _, err := db.Exec(cardTreesStmt); err != nil {
		return err
	}
	if _, err := db.Exec(cardTreeNodesStmt); err != nil {
		return err
	}
	if _, err := db.Exec(cardTreeAnnotationsStmt); err != nil {
		return err
	}
	if err := ensureCardTreeAnnotationColumns(db); err != nil {
		return err
	}
	if _, err := db.Exec(reportsStmt); err != nil {
		return err
	}
	if _, err := db.Exec(reportsIndexStmt); err != nil {
		return err
	}
	return nil
}

func migratePostgres(db *sql.DB) error {
	boardsStmt := `
	CREATE TABLE IF NOT EXISTS boards (
		id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
		name TEXT NOT NULL,
		description TEXT
	);`
	usersStmt := `
	CREATE TABLE IF NOT EXISTS users (
		id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
		username TEXT NOT NULL UNIQUE,
		password_hash TEXT NOT NULL,
		created TIMESTAMP NOT NULL
	);`
	threadsStmt := `
	CREATE TABLE IF NOT EXISTS threads (
		id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
		board_id INTEGER NOT NULL REFERENCES boards(id),
		title TEXT NOT NULL,
		author TEXT,
		tags TEXT,
		created TIMESTAMP NOT NULL
	);`
	postsStmt := `
	CREATE TABLE IF NOT EXISTS posts (
		id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
		thread_id INTEGER NOT NULL REFERENCES threads(id),
		author TEXT,
		content TEXT NOT NULL,
		created TIMESTAMP NOT NULL,
		number TEXT,
		flair TEXT,
		deleted_at TIMESTAMP,
		deleted_by TEXT,
		deleted_reason TEXT
	);`
	reportsStmt := `
	CREATE TABLE IF NOT EXISTS reports (
		id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
		post_id INTEGER NOT NULL REFERENCES posts(id) ON DELETE CASCADE,
		category TEXT NOT NULL,
		reason TEXT,
		reported_by TEXT,
		created TIMESTAMP NOT NULL,
		resolved_at TIMESTAMP,
		resolved_by TEXT,
		resolution_note TEXT
	);`
	reportsIndexStmt := `CREATE INDEX IF NOT EXISTS reports_post_id_idx ON reports(post_id);`
	cardTreesStmt := `
	CREATE TABLE IF NOT EXISTS card_trees (
		id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
		scope_type TEXT NOT NULL,
		scope_id INTEGER NOT NULL,
		title TEXT NOT NULL,
		description TEXT,
		created_by TEXT NOT NULL,
		created_at TIMESTAMP NOT NULL,
		updated_at TIMESTAMP NOT NULL,
		is_primary BOOLEAN NOT NULL DEFAULT FALSE
	);`
	cardTreeNodesStmt := `
	CREATE TABLE IF NOT EXISTS card_tree_nodes (
		id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
		tree_id INTEGER NOT NULL REFERENCES card_trees(id) ON DELETE CASCADE,
		parent_id INTEGER REFERENCES card_tree_nodes(id) ON DELETE CASCADE,
		card_name TEXT NOT NULL,
		position INTEGER NOT NULL DEFAULT 0,
		created_by TEXT NOT NULL,
		created_at TIMESTAMP NOT NULL,
		updated_at TIMESTAMP NOT NULL
	);`
	cardTreeAnnotationsStmt := `
	CREATE TABLE IF NOT EXISTS card_tree_annotations (
		id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
		node_id INTEGER NOT NULL REFERENCES card_tree_nodes(id) ON DELETE CASCADE,
		kind TEXT NOT NULL,
		body TEXT NOT NULL,
		label TEXT,
		tags TEXT,
		source_post_id INTEGER REFERENCES posts(id),
		created_by TEXT NOT NULL,
		created_at TIMESTAMP NOT NULL
	);`

	if _, err := db.Exec(boardsStmt); err != nil {
		return err
	}
	if _, err := db.Exec(usersStmt); err != nil {
		return err
	}
	if _, err := db.Exec(threadsStmt); err != nil {
		return err
	}
	if err := ensureThreadsAuthorColumn(db); err != nil {
		return err
	}
	if err := ensureThreadsTagsColumn(db); err != nil {
		return err
	}
	if _, err := db.Exec(postsStmt); err != nil {
		return err
	}
	if err := ensurePostModerationColumns(db); err != nil {
		return err
	}
	if _, err := db.Exec(cardTreesStmt); err != nil {
		return err
	}
	if _, err := db.Exec(cardTreeNodesStmt); err != nil {
		return err
	}
	if _, err := db.Exec(cardTreeAnnotationsStmt); err != nil {
		return err
	}
	if err := ensureCardTreeAnnotationColumns(db); err != nil {
		return err
	}
	if _, err := db.Exec(reportsStmt); err != nil {
		return err
	}
	if _, err := db.Exec(reportsIndexStmt); err != nil {
		return err
	}
	return nil
}

// seedData inserts a default board if none exist.
func seedData(db *sql.DB) error {
	var count int
	err := db.QueryRow("SELECT COUNT(*) FROM boards").Scan(&count)
	if err != nil {
		return err
	}
	if count == 0 {
		_, err := db.Exec(`INSERT INTO boards (name, description) VALUES ($1, $2)`, "/test/", "A test board.")
		if err != nil {
			return err
		}
	}
	return nil
}

func ensureThreadsAuthorColumn(db *sql.DB) error {
	_, err := db.Exec(`ALTER TABLE threads ADD COLUMN author TEXT`)
	if err == nil {
		_, _ = db.Exec(`UPDATE threads SET author = '' WHERE author IS NULL`)
		return nil
	}
	lower := strings.ToLower(err.Error())
	if strings.Contains(lower, "duplicate column") || strings.Contains(lower, "already exists") {
		_, _ = db.Exec(`UPDATE threads SET author = '' WHERE author IS NULL`)
		return nil
	}
	return err
}

func ensureThreadsTagsColumn(db *sql.DB) error {
	_, err := db.Exec(`ALTER TABLE threads ADD COLUMN tags TEXT`)
	if err == nil {
		return nil
	}
	lower := strings.ToLower(err.Error())
	if strings.Contains(lower, "duplicate column") || strings.Contains(lower, "already exists") {
		return nil
	}
	return err
}

func ensureCardTreeAnnotationColumns(db *sql.DB) error {
	columns := []string{
		"label TEXT",
		"tags TEXT",
	}
	for _, column := range columns {
		if dbDriver == "pgx" {
			if _, err := db.Exec(fmt.Sprintf(`ALTER TABLE card_tree_annotations ADD COLUMN IF NOT EXISTS %s`, column)); err != nil {
				return err
			}
			continue
		}
		_, err := db.Exec(fmt.Sprintf(`ALTER TABLE card_tree_annotations ADD COLUMN %s`, column))
		if err == nil {
			continue
		}
		lower := strings.ToLower(err.Error())
		if strings.Contains(lower, "duplicate column") || strings.Contains(lower, "already exists") {
			continue
		}
		return err
	}
	return nil
}

func ensurePostModerationColumns(db *sql.DB) error {
	var columns []string
	if dbDriver == "pgx" {
		columns = []string{
			"deleted_at TIMESTAMP",
			"deleted_by TEXT",
			"deleted_reason TEXT",
		}
	} else {
		columns = []string{
			"deleted_at DATETIME",
			"deleted_by TEXT",
			"deleted_reason TEXT",
		}
	}
	for _, column := range columns {
		if dbDriver == "pgx" {
			if _, err := db.Exec(fmt.Sprintf(`ALTER TABLE posts ADD COLUMN IF NOT EXISTS %s`, column)); err != nil {
				return err
			}
			continue
		}
		_, err := db.Exec(fmt.Sprintf(`ALTER TABLE posts ADD COLUMN %s`, column))
		if err == nil {
			continue
		}
		lower := strings.ToLower(err.Error())
		if strings.Contains(lower, "duplicate column") || strings.Contains(lower, "already exists") {
			continue
		}
		return err
	}
	return nil
}

// ensureSeedUser creates a default user when none exists for the configured username.
func ensureSeedUser(db *sql.DB, username, password string) error {
	if username == "" || password == "" {
		return nil
	}
	if userExists(db, username) {
		return nil
	}
	_, err := createUser(db, username, password)
	return err
}

// createBoard inserts a new board into the database.
func createBoard(db *sql.DB, name, description string) (*Board, error) {
	var id int
	if dbDriver == "pgx" {
		err := db.QueryRow(`INSERT INTO boards (name, description) VALUES ($1, $2) RETURNING id`, name, description).Scan(&id)
		if err != nil {
			return nil, err
		}
	} else {
		result, err := db.Exec(`INSERT INTO boards (name, description) VALUES ($1, $2)`, name, description)
		if err != nil {
			return nil, err
		}
		insertID, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		id = int(insertID)
	}
	return &Board{
		ID:          id,
		Name:        name,
		Description: description,
		Threads:     []*Thread{},
	}, nil
}

// getAllBoards retrieves all boards from the database.
func getAllBoards(db *sql.DB) ([]*Board, error) {
	rows, err := db.Query(`SELECT id, name, description FROM boards`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var boards []*Board
	for rows.Next() {
		var b Board
		if err := rows.Scan(&b.ID, &b.Name, &b.Description); err != nil {
			return nil, err
		}
		boards = append(boards, &b)
	}
	return boards, nil
}

// getBoardByID retrieves a specific board by ID, optionally loading its threads.
func getBoardByID(db *sql.DB, boardID int, loadThreads bool) (*Board, error) {
	var b Board
	err := db.QueryRow(`SELECT id, name, description FROM boards WHERE id = $1`, boardID).
		Scan(&b.ID, &b.Name, &b.Description)
	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("board not found")
	} else if err != nil {
		return nil, err
	}

	if loadThreads {
		threads, err := getThreadsByBoardID(db, boardID, true)
		if err != nil {
			return nil, err
		}
		b.Threads = threads
	}
	return &b, nil
}

func userExists(db *sql.DB, username string) bool {
	var id int
	err := db.QueryRow(`SELECT id FROM users WHERE username = $1`, username).Scan(&id)
	if err == sql.ErrNoRows {
		return false
	}
	return err == nil
}

func createUser(db *sql.DB, username, password string) (*User, error) {
	if userExists(db, username) {
		return nil, fmt.Errorf("username already exists")
	}
	passwordHash, err := hashPassword(password)
	if err != nil {
		return nil, err
	}
	now := time.Now()
	var id int
	if dbDriver == "pgx" {
		err := db.QueryRow(`INSERT INTO users (username, password_hash, created) VALUES ($1, $2, $3) RETURNING id`, username, passwordHash, now).Scan(&id)
		if err != nil {
			return nil, err
		}
	} else {
		result, err := db.Exec(`INSERT INTO users (username, password_hash, created) VALUES ($1, $2, $3)`, username, passwordHash, now)
		if err != nil {
			return nil, err
		}
		insertID, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		id = int(insertID)
	}
	return &User{
		ID:           id,
		Username:     username,
		PasswordHash: passwordHash,
		Created:      now,
	}, nil
}

func getUserPasswordHash(db *sql.DB, username string) (string, error) {
	var passwordHash string
	err := db.QueryRow(`SELECT password_hash FROM users WHERE username = $1`, username).Scan(&passwordHash)
	if err != nil {
		return "", err
	}
	return passwordHash, nil
}

func getUserByUsername(db *sql.DB, username string) (*User, error) {
	var user User
	err := db.QueryRow(`SELECT id, username, password_hash, created FROM users WHERE username = $1`, username).
		Scan(&user.ID, &user.Username, &user.PasswordHash, &user.Created)
	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("user not found")
	}
	if err != nil {
		return nil, err
	}
	return &user, nil
}

func getThreadsByAuthor(db *sql.DB, username string) ([]*ProfileThread, error) {
	rows, err := db.Query(`
		SELECT t.id, t.board_id, t.title, t.created
		FROM threads t
		LEFT JOIN (
			SELECT thread_id, MIN(created) AS first_created
			FROM posts
			GROUP BY thread_id
		) fp ON fp.thread_id = t.id
		LEFT JOIN posts fp_post
			ON fp_post.thread_id = t.id AND fp_post.created = fp.first_created
		WHERE t.author = $1
			OR ((t.author IS NULL OR t.author = '') AND fp_post.author = $2)
		ORDER BY t.created DESC`, username, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var threads []*ProfileThread
	for rows.Next() {
		var t ProfileThread
		if err := rows.Scan(&t.ID, &t.BoardID, &t.Title, &t.Created); err != nil {
			return nil, err
		}
		threads = append(threads, &t)
	}
	return threads, nil
}

func getPostsByAuthor(db *sql.DB, username string) ([]*ProfilePost, error) {
	rows, err := db.Query(`
		SELECT posts.id, posts.thread_id, threads.title, posts.content, posts.created, posts.deleted_at
		FROM posts
		JOIN threads ON posts.thread_id = threads.id
		WHERE posts.author = $1
		ORDER BY posts.created DESC`, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var posts []*ProfilePost
	for rows.Next() {
		var p ProfilePost
		var deletedAt sql.NullTime
		if err := rows.Scan(&p.ID, &p.ThreadID, &p.ThreadTitle, &p.Content, &p.Created, &deletedAt); err != nil {
			return nil, err
		}
		if deletedAt.Valid {
			p.Content = "Post removed by moderators."
		}
		posts = append(posts, &p)
	}
	return posts, nil
}

func authenticateUser(db *sql.DB, username, password string) bool {
	if username == "" || password == "" {
		return false
	}
	passwordHash, err := getUserPasswordHash(db, username)
	if err != nil {
		return false
	}
	return verifyPassword(password, passwordHash)
}

// createThread inserts a new thread into the database.
func createThread(db *sql.DB, boardID int, title, author string, tags []string) (*Thread, error) {
	now := time.Now()
	var id int
	tagString := strings.Join(normalizeTags(tags), ",")
	if dbDriver == "pgx" {
		err := db.QueryRow(`
		INSERT INTO threads (board_id, title, author, tags, created) 
		VALUES ($1, $2, $3, $4, $5)
		RETURNING id`,
			boardID, title, author, tagString, now).Scan(&id)
		if err != nil {
			return nil, err
		}
	} else {
		result, err := db.Exec(`
		INSERT INTO threads (board_id, title, author, tags, created) 
		VALUES ($1, $2, $3, $4, $5)`,
			boardID, title, author, tagString, now)
		if err != nil {
			return nil, err
		}

		insertID, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		id = int(insertID)
	}
	return &Thread{
		ID:      id,
		Title:   title,
		Author:  author,
		Posts:   []*Post{},
		Created: now,
		Tags:    normalizeTags(tags),
	}, nil
}

// getThreadsByBoardID retrieves all threads for a specific board, optionally loading their posts.
func getThreadsByBoardID(db *sql.DB, boardID int, loadPosts bool) ([]*Thread, error) {
	rows, err := db.Query(`
		SELECT id, title, author, tags, created
		FROM threads
		WHERE board_id = $1
		ORDER BY created DESC`, boardID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var threads []*Thread
	for rows.Next() {
		var t Thread
		var author sql.NullString
		var tagString sql.NullString
		if err := rows.Scan(&t.ID, &t.Title, &author, &tagString, &t.Created); err != nil {
			return nil, err
		}
		t.Author = author.String
		t.Tags = tagsFromString(tagString.String)

		if loadPosts {
			posts, err := getPostsByThreadID(db, t.ID)
			if err != nil {
				return nil, err
			}
			t.Posts = posts
		}
		threads = append(threads, &t)
	}
	return threads, nil
}

// getThreadByID retrieves a specific thread by ID, along with its posts and board ID.
func getThreadByID(db *sql.DB, threadID int) (*Thread, int, error) {
	var t Thread
	var boardID int
	var author sql.NullString
	var tagString sql.NullString
	err := db.QueryRow(`SELECT id, board_id, title, author, tags, created FROM threads WHERE id = $1`, threadID).
		Scan(&t.ID, &boardID, &t.Title, &author, &tagString, &t.Created)
	if err == sql.ErrNoRows {
		return nil, 0, fmt.Errorf("thread not found")
	} else if err != nil {
		return nil, 0, err
	}
	t.Author = author.String
	t.Tags = tagsFromString(tagString.String)

	posts, err := getPostsByThreadID(db, threadID)
	if err != nil {
		return nil, 0, err
	}
	t.Posts = posts

	return &t, boardID, nil
}

// createPost inserts a new post into the database.
func createPost(db *sql.DB, threadID int, author, content string) (*Post, error) {
	now := time.Now()
	number, flair := generateUniqueNumberAndFlair()
	var id int
	if dbDriver == "pgx" {
		err := db.QueryRow(`
		INSERT INTO posts (thread_id, author, content, created, number, flair) 
		VALUES ($1, $2, $3, $4, $5, $6)
		RETURNING id`,
			threadID, author, content, now, number.String(), flair).Scan(&id)
		if err != nil {
			return nil, err
		}
	} else {
		result, err := db.Exec(`
		INSERT INTO posts (thread_id, author, content, created, number, flair) 
		VALUES ($1, $2, $3, $4, $5, $6)`,
			threadID, author, content, now, number.String(), flair)
		if err != nil {
			return nil, err
		}
		insertID, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		id = int(insertID)
	}
	return &Post{
		ID:      id,
		Author:  author,
		Content: content,
		Created: now,
		Number:  number,
		Flair:   flair,
	}, nil
}

// generateUniqueNumberAndFlair generates a unique random large number and assigns a flair based on the number of preceding zeroes.
func generateUniqueNumberAndFlair() (*big.Int, string) {
	number, _ := rand.Int(rand.Reader, big.NewInt(1e10))
	numberStr := fmt.Sprintf("%d", number)

	zeroCount := 0
	for _, char := range numberStr {
		if char == '0' {
			zeroCount++
		} else {
			break
		}
	}

	var flair string
	switch zeroCount {
	case 1:
		flair = "uno"
	case 2:
		flair = "dubs"
	case 3:
		flair = "trips"
	case 4:
		flair = "quads"
	case 5:
		flair = "pents"
	default:
		flair = "default"
	}

	return number, flair
}

// getPostsByThreadID retrieves all posts for a specific thread.
func getPostsByThreadID(db *sql.DB, threadID int) ([]*Post, error) {
	rows, err := db.Query(`
		SELECT id, author, content, created, number, flair, deleted_at, deleted_by, deleted_reason
		FROM posts
		WHERE thread_id = $1
		ORDER BY created ASC`, threadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var posts []*Post
	for rows.Next() {
		var p Post
		var numberStr string
		var deletedAt sql.NullTime
		var deletedBy sql.NullString
		var deletedReason sql.NullString
		if err := rows.Scan(&p.ID, &p.Author, &p.Content, &p.Created, &numberStr, &p.Flair, &deletedAt, &deletedBy, &deletedReason); err != nil {
			return nil, err
		}
		if deletedAt.Valid {
			p.IsDeleted = true
			p.Content = ""
			p.DeletedAt = &deletedAt.Time
			p.DeletedBy = deletedBy.String
			p.DeletedReason = deletedReason.String
		}
		p.Number = new(big.Int)
		p.Number.SetString(numberStr, 10)
		posts = append(posts, &p)
	}
	postIDs := make([]int, 0, len(posts))
	for _, post := range posts {
		postIDs = append(postIDs, post.ID)
	}
	treesByPostID, err := getCardTreesByScopeIDs(db, "post", postIDs, true)
	if err != nil {
		return nil, err
	}
	for _, post := range posts {
		post.Trees = treesByPostID[post.ID]
	}
	return posts, nil
}

func createCardTree(db *sql.DB, scopeType string, scopeID int, title, description, createdBy string, isPrimary bool) (*CardTree, error) {
	if scopeType != "board" && scopeType != "thread" && scopeType != "post" {
		return nil, fmt.Errorf("invalid scope type")
	}
	now := time.Now()
	if isPrimary {
		if _, err := db.Exec(`UPDATE card_trees SET is_primary = FALSE WHERE scope_type = $1 AND scope_id = $2`, scopeType, scopeID); err != nil {
			return nil, err
		}
	}
	var id int
	if dbDriver == "pgx" {
		err := db.QueryRow(`
			INSERT INTO card_trees (scope_type, scope_id, title, description, created_by, created_at, updated_at, is_primary)
			VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
			RETURNING id`,
			scopeType, scopeID, title, description, createdBy, now, now, isPrimary).Scan(&id)
		if err != nil {
			return nil, err
		}
	} else {
		result, err := db.Exec(`
			INSERT INTO card_trees (scope_type, scope_id, title, description, created_by, created_at, updated_at, is_primary)
			VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
			scopeType, scopeID, title, description, createdBy, now, now, isPrimary)
		if err != nil {
			return nil, err
		}
		insertID, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		id = int(insertID)
	}
	return &CardTree{
		ID:          id,
		ScopeType:   scopeType,
		ScopeID:     scopeID,
		Title:       title,
		Description: description,
		CreatedBy:   createdBy,
		CreatedAt:   now,
		UpdatedAt:   now,
		IsPrimary:   isPrimary,
		Nodes:       []*CardTreeNode{},
	}, nil
}

func getCardTreesByScope(db *sql.DB, scopeType string, scopeID int, loadNodes bool) ([]*CardTree, error) {
	rows, err := db.Query(`
		SELECT id, scope_type, scope_id, title, description, created_by, created_at, updated_at, is_primary
		FROM card_trees
		WHERE scope_type = $1 AND scope_id = $2
		ORDER BY is_primary DESC, created_at DESC`, scopeType, scopeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var trees []*CardTree
	for rows.Next() {
		var t CardTree
		var description sql.NullString
		if err := rows.Scan(&t.ID, &t.ScopeType, &t.ScopeID, &t.Title, &description, &t.CreatedBy, &t.CreatedAt, &t.UpdatedAt, &t.IsPrimary); err != nil {
			return nil, err
		}
		t.Description = description.String
		if loadNodes {
			nodes, err := getCardTreeNodesByTreeID(db, t.ID)
			if err != nil {
				return nil, err
			}
			t.Nodes = nodes
		}
		trees = append(trees, &t)
	}
	return trees, nil
}

func getCardTreesByScopeIDs(db *sql.DB, scopeType string, scopeIDs []int, loadNodes bool) (map[int][]*CardTree, error) {
	treesByScope := make(map[int][]*CardTree)
	if len(scopeIDs) == 0 {
		return treesByScope, nil
	}

	placeholders := make([]string, len(scopeIDs))
	args := make([]interface{}, 0, len(scopeIDs)+1)
	args = append(args, scopeType)
	if dbDriver == "pgx" {
		for i, id := range scopeIDs {
			placeholders[i] = fmt.Sprintf("$%d", i+2)
			args = append(args, id)
		}
	} else {
		for i, id := range scopeIDs {
			placeholders[i] = "?"
			args = append(args, id)
		}
	}

	query := fmt.Sprintf(`
		SELECT id, scope_type, scope_id, title, description, created_by, created_at, updated_at, is_primary
		FROM card_trees
		WHERE scope_type = %s AND scope_id IN (%s)
		ORDER BY scope_id ASC, is_primary DESC, created_at DESC`,
		func() string {
			if dbDriver == "pgx" {
				return "$1"
			}
			return "?"
		}(),
		strings.Join(placeholders, ","),
	)
	rows, err := db.Query(query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	for rows.Next() {
		var t CardTree
		var description sql.NullString
		if err := rows.Scan(&t.ID, &t.ScopeType, &t.ScopeID, &t.Title, &description, &t.CreatedBy, &t.CreatedAt, &t.UpdatedAt, &t.IsPrimary); err != nil {
			return nil, err
		}
		t.Description = description.String
		if loadNodes {
			nodes, err := getCardTreeNodesByTreeID(db, t.ID)
			if err != nil {
				return nil, err
			}
			t.Nodes = nodes
		}
		treesByScope[t.ScopeID] = append(treesByScope[t.ScopeID], &t)
	}

	return treesByScope, nil
}

func getCardTreeByID(db *sql.DB, treeID int) (*CardTree, error) {
	var t CardTree
	var description sql.NullString
	err := db.QueryRow(`
		SELECT id, scope_type, scope_id, title, description, created_by, created_at, updated_at, is_primary
		FROM card_trees
		WHERE id = $1`, treeID).
		Scan(&t.ID, &t.ScopeType, &t.ScopeID, &t.Title, &description, &t.CreatedBy, &t.CreatedAt, &t.UpdatedAt, &t.IsPrimary)
	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("tree not found")
	}
	if err != nil {
		return nil, err
	}
	t.Description = description.String
	nodes, err := getCardTreeNodesByTreeID(db, t.ID)
	if err != nil {
		return nil, err
	}
	t.Nodes = nodes
	return &t, nil
}

func getCardTreeNodeTreeID(db *sql.DB, nodeID int) (int, error) {
	var treeID int
	err := db.QueryRow(`SELECT tree_id FROM card_tree_nodes WHERE id = $1`, nodeID).Scan(&treeID)
	if err == sql.ErrNoRows {
		return 0, fmt.Errorf("node not found")
	}
	if err != nil {
		return 0, err
	}
	return treeID, nil
}

func createCardTreeNode(db *sql.DB, treeID int, parentID *int, cardName string, position int, createdBy string) (*CardTreeNode, error) {
	if parentID != nil {
		parentTreeID, err := getCardTreeNodeTreeID(db, *parentID)
		if err != nil {
			return nil, err
		}
		if parentTreeID != treeID {
			return nil, fmt.Errorf("parent node does not belong to tree")
		}
	}
	now := time.Now()
	var id int
	if dbDriver == "pgx" {
		err := db.QueryRow(`
			INSERT INTO card_tree_nodes (tree_id, parent_id, card_name, position, created_by, created_at, updated_at)
			VALUES ($1, $2, $3, $4, $5, $6, $7)
			RETURNING id`,
			treeID, parentID, cardName, position, createdBy, now, now).Scan(&id)
		if err != nil {
			return nil, err
		}
	} else {
		result, err := db.Exec(`
			INSERT INTO card_tree_nodes (tree_id, parent_id, card_name, position, created_by, created_at, updated_at)
			VALUES ($1, $2, $3, $4, $5, $6, $7)`,
			treeID, parentID, cardName, position, createdBy, now, now)
		if err != nil {
			return nil, err
		}
		insertID, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		id = int(insertID)
	}
	return &CardTreeNode{
		ID:        id,
		TreeID:    treeID,
		ParentID:  parentID,
		CardName:  cardName,
		Position:  position,
		CreatedBy: createdBy,
		CreatedAt: now,
		UpdatedAt: now,
	}, nil
}

func updateCardTreeNode(db *sql.DB, nodeID int, parentID *int, cardName string, position int) error {
	treeID, err := getCardTreeNodeTreeID(db, nodeID)
	if err != nil {
		return err
	}
	if parentID != nil {
		parentTreeID, err := getCardTreeNodeTreeID(db, *parentID)
		if err != nil {
			return err
		}
		if parentTreeID != treeID {
			return fmt.Errorf("parent node does not belong to tree")
		}
	}
	now := time.Now()
	_, err = db.Exec(`
		UPDATE card_tree_nodes
		SET parent_id = $1, card_name = $2, position = $3, updated_at = $4
		WHERE id = $5`, parentID, cardName, position, now, nodeID)
	return err
}

func deleteCardTreeNode(db *sql.DB, nodeID int) error {
	_, err := db.Exec(`DELETE FROM card_tree_nodes WHERE id = $1`, nodeID)
	return err
}

func createCardTreeAnnotation(db *sql.DB, nodeID int, kind, body, label, tags string, sourcePostID *int, createdBy string) (*CardTreeAnnotation, error) {
	now := time.Now()
	var id int
	if dbDriver == "pgx" {
		err := db.QueryRow(`
			INSERT INTO card_tree_annotations (node_id, kind, body, label, tags, source_post_id, created_by, created_at)
			VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
			RETURNING id`,
			nodeID, kind, body, label, tags, sourcePostID, createdBy, now).Scan(&id)
		if err != nil {
			return nil, err
		}
	} else {
		result, err := db.Exec(`
			INSERT INTO card_tree_annotations (node_id, kind, body, label, tags, source_post_id, created_by, created_at)
			VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
			nodeID, kind, body, label, tags, sourcePostID, createdBy, now)
		if err != nil {
			return nil, err
		}
		insertID, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		id = int(insertID)
	}
	return &CardTreeAnnotation{
		ID:           id,
		NodeID:       nodeID,
		Kind:         kind,
		Body:         body,
		Label:        label,
		Tags:         tags,
		SourcePostID: sourcePostID,
		CreatedBy:    createdBy,
		CreatedAt:    now,
	}, nil
}

func deleteCardTreeAnnotation(db *sql.DB, annotationID int) error {
	_, err := db.Exec(`DELETE FROM card_tree_annotations WHERE id = $1`, annotationID)
	return err
}

func getCardTreeAnnotationsByTreeID(db *sql.DB, treeID int) (map[int][]*CardTreeAnnotation, error) {
	rows, err := db.Query(`
		SELECT a.id, a.node_id, a.kind, a.body, a.label, a.tags, a.source_post_id, a.created_by, a.created_at
		FROM card_tree_annotations a
		JOIN card_tree_nodes n ON a.node_id = n.id
		WHERE n.tree_id = $1
		ORDER BY a.created_at ASC`, treeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	annotations := make(map[int][]*CardTreeAnnotation)
	for rows.Next() {
		var a CardTreeAnnotation
		var sourcePostID sql.NullInt64
		if err := rows.Scan(&a.ID, &a.NodeID, &a.Kind, &a.Body, &a.Label, &a.Tags, &sourcePostID, &a.CreatedBy, &a.CreatedAt); err != nil {
			return nil, err
		}
		if sourcePostID.Valid {
			value := int(sourcePostID.Int64)
			a.SourcePostID = &value
		}
		annotations[a.NodeID] = append(annotations[a.NodeID], &a)
	}
	return annotations, nil
}

func getCardTreeNodesByTreeID(db *sql.DB, treeID int) ([]*CardTreeNode, error) {
	rows, err := db.Query(`
		SELECT id, tree_id, parent_id, card_name, position, created_by, created_at, updated_at
		FROM card_tree_nodes
		WHERE tree_id = $1
		ORDER BY position ASC, id ASC`, treeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var nodes []*CardTreeNode
	var roots []*CardTreeNode
	children := make(map[int][]*CardTreeNode)
	for rows.Next() {
		var n CardTreeNode
		var parentID sql.NullInt64
		if err := rows.Scan(&n.ID, &n.TreeID, &parentID, &n.CardName, &n.Position, &n.CreatedBy, &n.CreatedAt, &n.UpdatedAt); err != nil {
			return nil, err
		}
		if parentID.Valid {
			value := int(parentID.Int64)
			n.ParentID = &value
		}
		nodes = append(nodes, &n)
		if n.ParentID == nil {
			roots = append(roots, &n)
		} else {
			children[*n.ParentID] = append(children[*n.ParentID], &n)
		}
	}

	if len(nodes) == 0 {
		return nodes, nil
	}

	for _, list := range children {
		sort.Slice(list, func(i, j int) bool {
			if list[i].Position == list[j].Position {
				return list[i].ID < list[j].ID
			}
			return list[i].Position < list[j].Position
		})
	}
	sort.Slice(roots, func(i, j int) bool {
		if roots[i].Position == roots[j].Position {
			return roots[i].ID < roots[j].ID
		}
		return roots[i].Position < roots[j].Position
	})

	var ordered []*CardTreeNode
	var walk func(list []*CardTreeNode, depth int)
	walk = func(list []*CardTreeNode, depth int) {
		for _, node := range list {
			node.Depth = depth
			node.Indent = depth * 16
			ordered = append(ordered, node)
			if kids, ok := children[node.ID]; ok {
				walk(kids, depth+1)
			}
		}
	}
	walk(roots, 0)

	annotations, err := getCardTreeAnnotationsByTreeID(db, treeID)
	if err != nil {
		return nil, err
	}
	for _, node := range ordered {
		if list, ok := annotations[node.ID]; ok {
			node.Annotations = list
		}
	}
	return ordered, nil
}

func getPostThreadID(db *sql.DB, postID int) (int, error) {
	var threadID int
	err := db.QueryRow(`SELECT thread_id FROM posts WHERE id = $1`, postID).Scan(&threadID)
	if err == sql.ErrNoRows {
		return 0, fmt.Errorf("post not found")
	}
	if err != nil {
		return 0, err
	}
	return threadID, nil
}

func softDeletePost(db *sql.DB, postID int, deletedBy, reason string) error {
	now := time.Now()
	result, err := db.Exec(`
		UPDATE posts
		SET deleted_at = $1, deleted_by = $2, deleted_reason = $3
		WHERE id = $4 AND deleted_at IS NULL`, now, deletedBy, reason, postID)
	if err != nil {
		return err
	}
	rows, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if rows == 0 {
		return fmt.Errorf("post not found or already deleted")
	}
	return nil
}

func createReport(db *sql.DB, postID int, category, reason, reportedBy string) (*Report, error) {
	now := time.Now()
	var id int
	if dbDriver == "pgx" {
		err := db.QueryRow(`
			INSERT INTO reports (post_id, category, reason, reported_by, created)
			VALUES ($1, $2, $3, $4, $5)
			RETURNING id`,
			postID, category, reason, reportedBy, now).Scan(&id)
		if err != nil {
			return nil, err
		}
	} else {
		result, err := db.Exec(`
			INSERT INTO reports (post_id, category, reason, reported_by, created)
			VALUES ($1, $2, $3, $4, $5)`,
			postID, category, reason, reportedBy, now)
		if err != nil {
			return nil, err
		}
		insertID, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		id = int(insertID)
	}
	return &Report{
		ID:         id,
		PostID:     postID,
		Category:   category,
		Reason:     reason,
		ReportedBy: reportedBy,
		Created:    now,
	}, nil
}

func getOpenReports(db *sql.DB) ([]*ModReport, error) {
	rows, err := db.Query(`
		SELECT r.id, r.post_id, r.category, r.reason, r.reported_by, r.created,
			r.resolved_at, r.resolved_by, r.resolution_note,
			p.author, p.content, p.created, p.deleted_at, p.deleted_reason,
			t.id, t.title,
			b.id, b.name
		FROM reports r
		JOIN posts p ON r.post_id = p.id
		JOIN threads t ON p.thread_id = t.id
		JOIN boards b ON t.board_id = b.id
		WHERE r.resolved_at IS NULL
		ORDER BY r.created DESC`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var reports []*ModReport
	for rows.Next() {
		var r ModReport
		var resolvedAt sql.NullTime
		var resolvedBy sql.NullString
		var resolutionNote sql.NullString
		var deletedAt sql.NullTime
		var deletedReason sql.NullString
		if err := rows.Scan(
			&r.ID,
			&r.PostID,
			&r.Category,
			&r.Reason,
			&r.ReportedBy,
			&r.Created,
			&resolvedAt,
			&resolvedBy,
			&resolutionNote,
			&r.PostAuthor,
			&r.PostContent,
			&r.PostCreated,
			&deletedAt,
			&deletedReason,
			&r.ThreadID,
			&r.ThreadTitle,
			&r.BoardID,
			&r.BoardName,
		); err != nil {
			return nil, err
		}
		if resolvedAt.Valid {
			r.ResolvedAt = &resolvedAt.Time
		}
		if resolvedBy.Valid {
			r.ResolvedBy = resolvedBy.String
		}
		if resolutionNote.Valid {
			r.ResolutionNote = resolutionNote.String
		}
		if deletedAt.Valid {
			r.PostDeleted = true
			r.PostDeletedReason = deletedReason.String
		}
		reports = append(reports, &r)
	}
	return reports, nil
}

func resolveReport(db *sql.DB, reportID int, resolvedBy, note string) error {
	now := time.Now()
	result, err := db.Exec(`
		UPDATE reports
		SET resolved_at = $1, resolved_by = $2, resolution_note = $3
		WHERE id = $4 AND resolved_at IS NULL`, now, resolvedBy, note, reportID)
	if err != nil {
		return err
	}
	rows, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if rows == 0 {
		return fmt.Errorf("report not found or already resolved")
	}
	return nil
}

// deleteBoardByID deletes a board and its associated threads and posts from the database.
func deleteBoardByID(db *sql.DB, boardID int) error {
	_, err := db.Exec(`DELETE FROM boards WHERE id = $1`, boardID)
	if err != nil {
		return err
	}
	_, err = db.Exec(`DELETE FROM threads WHERE board_id = $1`, boardID)
	if err != nil {
		return err
	}
	_, err = db.Exec(`DELETE FROM posts WHERE thread_id IN (SELECT id FROM threads WHERE board_id = $1)`, boardID)
	return err
}

func hashPassword(password string) (string, error) {
	salt := make([]byte, 16)
	if _, err := rand.Read(salt); err != nil {
		return "", err
	}
	sum := sha256.Sum256(append(salt, []byte(password)...))
	return base64.RawURLEncoding.EncodeToString(salt) + ":" + base64.RawURLEncoding.EncodeToString(sum[:]), nil
}

func verifyPassword(password, stored string) bool {
	parts := strings.SplitN(stored, ":", 2)
	if len(parts) != 2 {
		return false
	}
	salt, err := base64.RawURLEncoding.DecodeString(parts[0])
	if err != nil {
		return false
	}
	hash, err := base64.RawURLEncoding.DecodeString(parts[1])
	if err != nil {
		return false
	}
	sum := sha256.Sum256(append(salt, []byte(password)...))
	return hmac.Equal(hash, sum[:])
}
